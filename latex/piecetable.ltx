\documentclass{patmorin}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{minted}

\title{Practical piece tables}
\author{Thomas Qu}

\begin{document}
\maketitle

\begin{abstract}
	In progress... this doc will be tidied up later.
\end{abstract}

\tableofcontents
\newpage

\section{Motivation}

What are the requirements on a text editor buffer?
Bram Moolenaar (author of the Vim editor) proposes the following criteria:

\begin{itemize}
\item Reading and writing files should be fast.
\item No restrictions on line length, file length or character set.
\item Making changes in the text should be quick.
\item The code to handle the text shouldn't be too big.
\item Allow for undoing changes.
\item When the system crashes, recovering unsaved changes must be possible.
\end{itemize}

We briefly cover each point.

\subsection{\emph{Reading and writing files should be fast}}

It is desirable to load files quickly. Data structures which manipulate the whole file
in-memory (such as most rope implementations) in buffers of fixed size do not scale well
in this respect, as the whole file's contents must be copied.
Further, it's possible files may not even fit in memory.

Another option is to implement a paging system, as seen in Vim.
However this involves considerable complexity as well as consequences for performance.

The piece table solves this problem by utilizing the operating system's virtual memory paging facilities.

\subsection{\emph{No restrictions on line length, file length or character set}}

In the author's experience, Vim itself struggles on long \texttt{typescript} dumps.

\section{some notes}

\begin{itemize}
	\item Splay trees are difficult to use concurrently, as to implement reads efficiently,
		mutating the tree is necessary in splaying visited nodes to the root.
	\item Using a sequence of 'patches' (as used in Atom) tracking both inserted text and deletions from the original provides questionable (at maximum halving the number of nodes) benefits for a considerable increase in complexity.
	\item Finseth[1]'s comments on the 'difference file' method is most applicable to Atom, which essentially manipulates edits as an in-memory diff. However the argument that edit tracking may entail additional memory overhead is annulled by the need to support undo.
	\item Indexing in codepoints is unnecessary in an editor buffer, as in the vast majority of cases code operates sequentially on grapheme clusters (e.g. deleting a character, cursor movement) or bytes (e.g. searching). Further, the desired behaviour is unclear in the case of files containing invalid multibyte sequences, which may often occur when dealing with binary files or corrupted data. Overall the additional complexity of tracking codepoints does not seem to be generally worthwhile in the context of a text editor.
	\item Using the invariant of adjacent nodes is simpler (avoiding unnecessary 'stealing' cases) and at most differs from rope balancing by one level of depth.
	\item unsafe COW allows for a transient API to be implemented by the type system of a higher-level wrapper. Operations on the persistent version edit on a clone, whilst the transient version only needs to clone once, and tracks this with a flag.
	\item Further work: The generalization of a focus [see embedding-rrb] is interesting but adds significant complexity to implementation. It remains unclear whether the performance advantages in certain cases will be significant.
\end{itemize}

\section{Bibliography}

https://www.finseth.com/craft
https://www.cs.unm.edu/~crowley/papers/sds.pdf
https://blog.atom.io/2017/10/12/atoms-new-buffer-implementation.html
https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation
https://www.free-soft.org/FSM/english/issue01/vim.html

\end{document}
